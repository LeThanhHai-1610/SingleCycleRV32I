
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module RISCV_v1(

	//////////// CLOCK //////////
	input 		          		  CLOCK_50,
	input 		       [31:0]    in1,
	input                        reset,
	//input 		       [31:0]    in2,
	//////////// SW //////////
	input 		       [9:0]	  SW,

	//////////// LED //////////
	output		       [9:0]	  LEDR,

	//////////// Seg7 //////////
	
	//output		       [31:0]    r,
	output 		       [31:0]    r1,
	output		        [6:0]	  HEX5
);

//=======================================================
//  REG/WIRE declarations
//=======================================================
wire [6:0]  w_opcode	   ;   // out ID
wire [4:0]  w_rd	 	   ;   // out ID
wire [4:0]  w_rs1	 	   ;   // out ID
wire [4:0]  w_rs2	 	   ;   // out ID
wire [2:0]  w_funct3	   ;   // out ID
wire [6:0]  w_funct7	   ;   // out ID
wire [2:0]  w_type	   ;   // out ID, in ImmGen
wire [31:0] w_imm	 	   ;   // out ImmGen
wire [31:0] w_addr_ins  ;   // out PC, in Reg_IF_ID
wire [31:0] w_addr_ins_reg  ;   // out Reg_IF_ID, in IM
wire [31:0] w_addr_ins1 ;   // input of A of adder 1 to calculate nextPC (currentPC or rs1)
wire [31:0] w_ins       ;   // out IM, in ID, in Reg_IF_ID
wire [31:0] w_ins_reg   ;   // out Reg_IF_ID, in ImmGen
wire [31:0] w_readdata1, w_readdata2	 	 ; // out RegFile, in ALU
wire [31:0] w_inALU2    ;   // in ALU2
wire [31:0] w_inALU1    ;   // in ALU1
wire        w_Branch, w_MemtoReg, w_MemRd, w_MemWr, w_RegWr; // out Control unit
wire [3:0]  w_ALUOp     ;   // out Control unit
wire [31:0] w_ALUresult ;   // out ALU, in DataMem
wire [31:0] w_ReadData  ;   // out DataMem, 
wire [31:0] w_WriteData ;   // in RegFile,
wire [31:0] w_WriteData1;   // out Mux after DataMem,
wire [31:0] w_MemDataWr ;   // in DataMem
wire        w_zero      ;   // out ALU,
wire        w_lt        ;   // out ALU,
wire [1:0]  w_BrOp      ;   // out Control unit
wire [31:0] w_Normal_ins;   // out Adder1, PC + 4
wire [31:0] w_Branch_ins;   // out Adder2,
wire [31:0] w_Next_ins  ;   // out mux top, in PC
wire        w_Next_ins_temp, w_Next_ins_temp1;
wire        w_ALUOF, w_ALUneg, w_adder1OF, w_adder1zero, w_adder2OF, w_adder2zero; // non-connect
wire        w_Jump, w_PCspecial;
wire [1:0]  w_Asel, w_ALUSrc   ; // select inputs of 1st and 2nd ALU operand
wire [2:0]  w_Load_sel;
wire [1:0]  w_Store_sel;
//=======================================================
//  Structural coding
//=======================================================

Control_Unit (
    //.clk       (CLOCK_50)  ,
    //.rst_n ()    ,
	 .type      (w_type)     ,
    .opcode    (w_opcode)   ,  
    .funct7    (w_funct7)   ,
    .funct3    (w_funct3)   ,
    .Branch    (w_Branch)   , // notify B-type instruction
	 .Jump      (w_Jump)     , // notify J-type instruction and Jump
	 .PCspecial (w_PCspecial), // only 1 when jalr (nextPC depends on rs1); otherwise NextPC depends on currentPC)
    .MemtoReg  (w_MemtoReg) , // connect to mux after DataMem
    .ALUSrc    (w_ALUSrc)   , // connect to mux select input ALU2
	 .Asel      (w_Asel)     , // select input of 1st operand of ALU
    .MemRd     (w_MemRd)    , // connect to DataMem  
	 .MemWr     (w_MemWr)    , // connect to DataMem
    .RegWr     (w_RegWr)    , // connect to registers file
	 .BrOp      (w_BrOp)     ,
	 .Load_sel  (w_Load_sel) ,
	 .Store_sel (w_Store_sel),
    .ALUOp     (w_ALUOp)      // connect to ALU
);

ALU mainALU (
	 .in1        (w_inALU1),
	 .in2        (w_inALU2)   ,
	 .sel        (w_ALUOp)    ,
	 .ALU_result (w_ALUresult),
	 .ALU_of     (w_ALUOF)    ,
	 .ALU_zero   (w_zero)     ,
	 .ALU_lt     (w_lt),
	 .ALU_neg    (w_ALUneg)
);

module_32_D_FF PC (
    .i_clr      (0)         ,
    //.i_CE       (1)         , 
    .i_D        (w_Next_ins),
	 .i_clk      (CLOCK_50)  ,
	 .o_Q        (w_addr_ins)
);

Instruction_Memory IM (
    .pc          (w_addr_ins),
    //.clk         (CLOCK_50)  ,
    .instruction (w_ins)     
);

/*Reg_IF_ID (
    .clk   (CLOCK_50),
	 .rst   (reset),
    .if_pc (w_addr_ins) ,
    .if_inst (w_ins),
	 .id_pc (w_addr_ins_reg) ,
    .id_inst (w_ins_reg)
);*/

Instruction_Decode ID (
  .instruction  (w_ins)   , 
  .opcode       (w_opcode),
  .rd           (w_rd)    ,
  .rs1          (w_rs1)   ,
  .rs2          (w_rs2)   ,
  .funct3       (w_funct3),
  .funct7       (w_funct7),
  .type			 (w_type)
);

RegisterFile RegFile (
	.readreg1    (w_rs1)      ,
	.readreg2    (w_rs2)      ,
	.writereg    (w_rd)       ,
	.writedata   (w_WriteData),
	.write       (w_RegWr)    ,
	.clk         (CLOCK_50)   ,
	.rst_n       (1)          ,
	.readdata1   (w_readdata1),
	.readdata2	 (w_readdata2)
);

assign r1 = w_readdata2;
assign w_addr_ins1 = (w_PCspecial) ? w_readdata1 : w_addr_ins; 
CLA Adder1 (
    .i_A        (w_addr_ins1) ,
	 .i_B        (w_imm)       ,
	 .i_mode     (0)           ,   //0: add; 1: sub
	 .S          (w_Branch_ins),
	 .overflow   (w_adder1OF)  ,
	 .zero       (w_adder1zero)
);
CLA Adder2 (
    .i_A        (w_addr_ins)  ,
	 .i_B        (3'b100)      ,
	 .i_mode     (0)           ,   //0: add; 1: sub
	 .S          (w_Normal_ins),
	 .overflow   (w_adder2OF)  ,
	 .zero       (w_adder2zero)
);
assign w_Next_ins_temp = (w_BrOp[1]) ? (w_BrOp[0] ? (~w_lt) & w_Branch : w_lt & w_Branch) : (w_BrOp[0] ? ~(w_zero) & w_Branch : w_zero & w_Branch);// mux PC selection
assign w_Next_ins_temp1 = w_Next_ins_temp | w_Jump;
assign w_Next_ins = (w_Next_ins_temp1) ? w_Branch_ins : w_Normal_ins;

Data_Memory DataMem (
    .clk        (CLOCK_50)   ,
    .Address    (w_ALUresult),
    .DataWrite  (w_MemDataWr),
    .MemWr      (w_MemWr)    ,
    .MemRd      (w_MemRd)    ,
    .ReadData   (w_ReadData)        
);
assign w_WriteData1 = (w_MemtoReg == 1) ? w_ReadData : w_ALUresult; // mux after DataMem
assign w_WriteData = (w_Load_sel[2]) ? w_WriteData1 : (w_Load_sel[1]) ? (w_Load_sel[0]) ? {16'b0,w_WriteData1[15:0]} : {24'b0,w_WriteData1[7:0]} : (w_Load_sel[0]) ? {{16{w_WriteData1[15]}},w_WriteData1[15:0]}: {{24{w_WriteData1[7]}},w_WriteData1[7:0]};
assign w_MemDataWr = (w_Store_sel[1]) ? w_readdata2 : (w_Store_sel[0]) ? {{16{w_readdata2[15]}},w_readdata2[15:0]} : {{24{w_readdata2[7]}},w_readdata2[7:0]};
//assign r1 = w_WriteData;

Imm_Gen ImmGen (
    .inst 		  (w_ins)  , 
    .type     	  (w_type) ,	
    .imm         (w_imm)  ,
);
assign w_inALU2 = (w_ALUSrc[1] == 0) ? (w_ALUSrc[0] ? w_imm : w_readdata2) : 3'b100; // mux before ALU2; 00:rs2, 01:imm, 10: 4
assign w_inALU1 = (w_Asel[1]) ? 3'b000 : (w_Asel[0] ? w_addr_ins : w_readdata1) ; // mux before ALU1; 00:rs1, 01:PC, 10: 0
endmodule







